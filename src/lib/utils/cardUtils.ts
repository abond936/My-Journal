import { HydratedCard, CardUpdate, GalleryMediaItem } from '@/lib/types/card';
import { Media } from '@/lib/types/photo';
import { Node } from 'prosemirror-model';
import { Editor } from '@tiptap/react';

/**
 * Extracts media IDs from the HTML string saved in a card's `content` field.
 * We look for any <figure data-media-id="â€¦"> generated by TipTap's FigureWithImage node.
 */
export function extractMediaFromContent(html: string | null | undefined): string[] {
  if (!html || typeof html !== 'string') return [];

  const ids = new Set<string>();
  const regex = /<figure[^>]*data-media-id=["']([^"']+)["']/gi;
  let match: RegExpExecArray | null;
  while ((match = regex.exec(html)) !== null) {
    ids.add(match[1]);
  }
  return Array.from(ids);
}

export function transformToCardUpdate(hydratedCard: HydratedCard): CardUpdate {
  const skinnyGalleryMedia = hydratedCard.galleryMedia.map(item => ({
    mediaId: item.mediaId,
    caption: item.caption,
    objectPosition: item.objectPosition,
  }));

  const contentMedia = extractMediaFromContent(hydratedCard.content);

  return {
    title: hydratedCard.title,
    status: hydratedCard.status,
    content: hydratedCard.content,
    tags: hydratedCard.tags,
    childCardIds: hydratedCard.childCardIds,
    coverImageId: hydratedCard.coverImageId,
    coverImageObjectPosition: hydratedCard.coverImageObjectPosition,
    galleryMedia: skinnyGalleryMedia,
    contentMedia,
  };
}

/**
 * Removes transient fields (coverImage, galleryMedia[].media, contentMedia objects) so the
 * resulting payload matches the Firestore card schema.
 */
export function dehydrateCardForSave(raw: any): CardUpdate {
  const { coverImage: _ci, galleryMedia, contentMedia, ...rest } = raw;

  console.log('[dehydrateCardForSave] Input content length:', raw.content?.length);

  const dehydratedGallery = galleryMedia?.map((item: any) => {
    const { media: _m, ...g } = item || {};
    return g;
  });

  // Ensure contentMedia is always an array before saving.
  const cleanedContent = Array.isArray(contentMedia)
    ? contentMedia.map((e: any) => (typeof e === 'string' ? e : e.id))
    : contentMedia
      ? [ (typeof contentMedia === 'string' ? contentMedia : contentMedia.id) ]
      : [];

  const result = {
    ...rest,
    content: raw.content, // Explicitly preserve content
    ...(dehydratedGallery ? { galleryMedia: dehydratedGallery } : {}),
    ...(cleanedContent ? { contentMedia: cleanedContent } : {}),
  } as CardUpdate;

  console.log('[dehydrateCardForSave] Output content length:', result.content?.length);

  return result;
}

/**
 * Ensures that each <figure> in the HTML content points at the canonical `storageUrl` of its media.
 * This replaces any temporary or proxy URL that may have been inserted during editing.
 */
export function normalizeContentImageSrc(html: string, mediaMap: Map<string, Media>): string {
  if (!html) return html;
  let updated = html;
  for (const [id, media] of mediaMap.entries()) {
    if (!media?.storageUrl) continue;

    const tagRegex = new RegExp(
      `<(figure|img)([^>]*?data-media-id=["']${id}["'][^>]*?)>`,
      'gi'
    );

    updated = updated.replace(tagRegex, (tag, tagName, attrs) => {
      if (/src=/.test(tag)) {
        return tag.replace(/src=["'][^"']*["']/, `src="${media.storageUrl}"`);
      }
      return tag.replace(`<${tagName}`, `<${tagName} src="${media.storageUrl}"`);
    });
  }
  return updated;
}

export function stripContentImageSrc(html: string | null | undefined): string {
  if (!html || typeof html !== 'string') {
    return html || '';
  }

  console.log('[stripContentImageSrc] Input length:', html.length);
  console.log('[stripContentImageSrc] First 200 chars:', html.slice(0, 200));

  // First handle standalone img tags
  let result = html.replace(/<img[^>]*data-media-id=["'][^"']+["'][^>]*>/gi, (tag) => {
    // Remove the src="..." portion if it exists
    return tag.replace(/\s+src=["'][^"']*["']/i, '');
  });

  // Then handle figure tags with nested img tags
  result = result.replace(
    /<figure[^>]*data-media-id=["'][^"']+["'][^>]*>(\s*<img[^>]*>.*?)<\/figure>/gi,
    (match, imgContent) => {
      // Keep the figure tag intact but strip src from the nested img
      const cleanedImgContent = imgContent.replace(/\s+src=["'][^"']*["']/i, '');
      return match.replace(imgContent, cleanedImgContent);
    }
  );

  console.log('[stripContentImageSrc] Output length:', result.length);
  console.log('[stripContentImageSrc] First 200 chars of output:', result.slice(0, 200));

  return result;
}

/**
 * Injects the permanent storageUrl for each mediaId into its corresponding <img> tag.
 * If the tag already contains a src attribute it will be overwritten; otherwise it is added.
 */
export function hydrateContentImageSrc(html: string | null | undefined, mediaMap: Map<string, Media>): string {
  if (!html || typeof html !== 'string') {
    return html || '';
  }

  console.log('[hydrateContentImageSrc] Input length:', html.length);
  console.log('[hydrateContentImageSrc] First 200 chars:', html.slice(0, 200));

  // First handle standalone img tags
  let result = html.replace(/<img[^>]*data-media-id=["']([^"']+)["'][^>]*>/gi, (tag, mediaId: string) => {
    const media = mediaMap.get(mediaId);
    if (!media || !media.storageUrl) {
      return tag;
    }

    // If a src attribute already exists, replace its value; otherwise insert it after <img
    if (/src=["'][^"']*["']/i.test(tag)) {
      return tag.replace(/src=["'][^"']*["']/i, `src="${media.storageUrl}"`);
    }
    return tag.replace(/^<img/i, `<img src="${media.storageUrl}"`);
  });

  // Then handle figure tags with nested img tags
  result = result.replace(
    /<figure[^>]*data-media-id=["']([^"']+)["'][^>]*>(\s*<img[^>]*>.*?)<\/figure>/gi,
    (match, mediaId: string, imgContent: string) => {
      const media = mediaMap.get(mediaId);
      if (!media || !media.storageUrl) {
        return match;
      }

      // Update or add src to the nested img tag
      const updatedImgContent = imgContent.replace(/<img([^>]*)>/i, (imgTag) => {
        if (/src=["'][^"']*["']/i.test(imgTag)) {
          return imgTag.replace(/src=["'][^"']*["']/i, `src="${media.storageUrl}"`);
        }
        return imgTag.replace(/^<img/i, `<img src="${media.storageUrl}"`);
      });

      return match.replace(imgContent, updatedImgContent);
    }
  );

  console.log('[hydrateContentImageSrc] Output length:', result.length);
  console.log('[hydrateContentImageSrc] First 200 chars of output:', result.slice(0, 200));

  return result;
} 
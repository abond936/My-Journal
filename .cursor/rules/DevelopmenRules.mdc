---
description: 
globs: 
alwaysApply: true
---
```

Development Rules

- Code is to be modular with self-contained components.
- Edit only specific code under consideration.
- Make only changes authorized to make 
- Do not make changes to code outside the scope of the question/issue at hand.
  - For example, do not delete comments, rename variables, or change any code not specifically related to the functionality at hand.
- Comment all code extensively in layman's terms
- Follow the directory structure for creation of new code
  - If the location is unclear, stop, explain options and ask for clarification and approval
- Keep css modules with components
- Always reference the actual type definitions in src/lib/types/ before proposing model changes.
- Use service functions for all database functions
- When working with tags, always use the tag service for expansion and hierarchy.
- When working with media, always reference by ID and use the media service for import/delete.
- If unsure about a field or logic, cite the code and ask for clarification.

Before proposing any code or refactor, evaluate the following:
- Will this change affect existing data flow, contracts, or modules?
- Does this align with our architectural rules and tech stack?
- Are there downstream implications for other components or deployment?

- Explain the change and impact on current logic and file structure

Naming Conventions
- Use kebab-case for folders and CSS files
- Use PascalCase for React components
- Use camelCase for:
  - Hooks
  - Utilities
  - Types
  - Services
  - Scripts
  - JavaScript variables
  - Function names
- Use .module.css for component styles


**Script Execution**
- Use PowerShell for script execution

  ```powershell
  npx ts-node -r tsconfig-paths/register -P tsconfig.scripts.json src/lib/scripts/<script-name>
  ```

- Handle file operations sequentially, not in parallel
- Validate file operations before proceeding
- Use proper error handling for file operations
- Log operation results

**CSS**

#### Core Principles
- Use mobile-first philosophy
- Use fluid-first approach with relative units (%, vw, vh)
- Implement smooth scaling with `clamp()` and `min()`
- Use breakpoints only for fundamental layout changes
- Current breakpoint: 640px (mobile layout switch)

#### Implementation Guidelines
```css
/* Preferred approach */
.element {
  width: min(400px, 50vw);  /* Fluid with max constraint */
  margin: clamp(1rem, 3vw, 1.5rem);  /* Fluid with min/max */
  font-size: clamp(1rem, 2vw, 1.125rem);  /* Fluid typography */
 }
```

- Image Sizes
  - Small: `width: min(200px, 30vw)`
  - Medium: `width: min(400px, 50vw)`
  - Large: `width: min(600px, 70vw)`

- Container Sizing
  - Use `min()` for maximum width constraints
  - Allow fluid scaling within bounds
  - Example: `width: min(100%, 1200px)`

- Spacing
  - Use `clamp()` for fluid margins and padding
  - Scale with viewport: `clamp(min, preferred, max)`
  - Example: `margin: clamp(1rem, 3vw, 1.5rem)`

- Typography
      - Implement fluid typography with `clamp()`
      - Maintain readability at all sizes
      - Example: `font-size: clamp(1rem, 2vw, 1.125rem)`

- Transitions
  - Add smooth transitions for size changes
    - Example: `transition: width 0.3s ease, margin 0.3s ease`

- Breakpoints
  - Only for fundamental layout changes
  - When switching from multi-column to single-column
  - When changing float behavior

- Fluid Sizing**
  - For all size-related properties
  - For spacing and margins
  - For typography
  - For image dimensions

- Performance Considerations
  - Minimize number of media queries
  - Use efficient CSS properties
  - Consider using CSS custom properties for common values
